/*
      Name: Elizabeth Brooks
      File: ProbabilityDistribution class
      Modified: 18 January 2017
*/
//Imports
import java.security.SecureRandom;
import java.util.Random;
//Java class to draw the sxpecified distribution based on input values
public class ProbabilityDistribution{
   	//Class fields
   	private static String OS = System.getProperty("os.name").toLowerCase(); //Current OS program is being run on
   	private SecureRandom secureRandomUnifromObject; //Use SecureRandom for high quality random numbers, 20x slower than Random
   	private SecureRandom nativeRandomObject; //Use SecureRandom to generate a native PRNG to seed for SHA1 PRNG
   	private Random randomUniformObject; //Use Random for low quality random numbers
   	private double randomUniformNum = 0; //Variable for storing the currently generated uniform random number
   	private double randomSigmoidNum = 0;//Variable for storing the currently generated sigmoid random number
   	private String randomChoice = "random"; //Variable for random number quality choice
   	private byte[] nativeSeed; //Seed generated by NativePRNGNonBlocking
   	private byte[] byteValues; //Values generated by SHA1PRNG
      //Default class constructur
      public ProbabilityDistribution(){
            randomChoice = "random"; //Default Random class quality numbers
            randomUniformObject = new Random(); //Initialize default low quality random number object
      }//End default constructur
   	//Class contructor to initialize and select distribution
   	//Users may select random number quality, default Random
   	public ProbabilityDistribution(String randomChoiceInput){
      		randomChoice = randomChoiceInput;
      		if(randomChoice.equals("random")){
         		randomUniformObject = new Random(); //Initialize low quality random number object
      		}else if(randomChoice.equals("secure")){
			         try{
            			if((OS.indexOf("mac") >= 0) || (OS.indexOf("nix") >= 0) || (OS.indexOf("nux") >= 0) || (OS.indexOf("aix") > 0)){ //Determine current OS for random number operation
               				secureRandomUnifromObject = new SecureRandom(); //Initialize secure random number object and let the system choose the provider and service provider interface, using NativePRNG service provider interface
					            byteValues = new byte[20];
               				secureRandomUnifromObject.nextBytes(byteValues); //Seed NativePRNG default object
            			}else if((OS.indexOf("win") >= 0)){
               				secureRandomUnifromObject = SecureRandom.getInstance("SHA1PRNG");//Initialize secure random number object and let the system choose the provider, using the SHA1PRNG service provider interface
					            nativeRandomObject = SecureRandom.getInstance("NativePRNGNonBlocking"); //Initialize secure random object for native PRNG, non blocking
               				nativeSeed = nativeRandomObject.generateSeed(55); //NIST SP800-90A suggests 440 bits for SHA1 seed
               				secureRandomUnifromObject.setSeed(nativeSeed); //Set seed using the non blocking native PRNG object
               				byteValues = new byte[20];
               				secureRandomUnifromObject.nextBytes(byteValues); //Seed SHA1PRNG object
            			}else{
               				secureRandomUnifromObject = new SecureRandom(); //Initialize secure random number object and let the system choose the provider and service provider interface, using NativePRNG service provider interface
					            byteValues = new byte[20];
               				secureRandomUnifromObject.nextBytes(byteValues); //Seed NativePRNG default object
            			}//End else
         		} catch (Exception e) {
            			System.err.println("Error retriving current OS for random number generation");
         		}//End catch
      		}else{
         		System.err.println("Incorrect input for random quality choice");
      		}//End else
   	}//End constructor
      //Method to generate uniform random numbers in the interval [0,1] of either low (Random) or  high (SecureRandom) quality
      public double nextUniform(){
         //Generate a uniform random number of the user specified quality
         if(randomChoice.equals("random")){
         		randomUniformNum = randomUniformObject.nextDouble(); //Generate uniform random number in the interval [0,1]
      	}else if(randomChoice.equals("secure")){
               randomUniformNum = secureRandomUnifromObject.nextDouble(); //Generate uniform random number in the interval [0,1]
         }else{
               System.err.println("Incorrect input for random quality choice");
      	}//End else
         return randomUniformNum;
      }//End nextUniform
   	//Method to transfrom a uniform random probability to fit a sigmoid distribution
   	//using inverse transform sampling and logit, the inverse of the sigmoid function
   	//to return the log odds of the generated uniform random probability
   	public double nextLogOdds(){
      		//Transform a uniform random number in the interval [0,1] to fit a sigmoid, cumulative distribution function(CDF)using logit, 
      		//the inverse sigmoig function to return a random x in the sigmoid distribution given the input random uniform probability value
      		return randomSigmoidNum = Math.log(randomUniformNum/(1-randomUniformNum)); //Return the log odds of the generated random uniform number
   	}//End nextLogOdds
      //Method to return a random value of a sigmoid distribution using the inverse sigmoid function, logit,
      //which is the quantile function of the cummulative distribution with a sigmoid curve
      public double nextQuantileSigmoid(){
            nextUniform();//Generate uniform random number in the interval [0,1]
            return nextLogOdds();//Return random sigmoid value using logit, the log odds of the generated uniform random number
      }//End nextQuantileSigmoid
   	//Method to transform a uniform random probability to fit a normal distribution
   	//using the ziggurat algorithm
   	public double nextGaussian(){
            //Step 1: Choose a random layer 0 <= i < n
      		//Step 2: Let X = U0*Xi
      		//Step 3: If X < Xi+1, return X
      		//Step 4: If i = 0, generate a point from the tail using the fallback algorithm
      		//Step 5: Let Y = Yi + U1(Yi+1 - Yi)
      		//Step 6: Compute f(X). If y < f(X), return X
      		//Step 7: Otherwise, choose new random numbers and go back to step 1
            if(randomChoice.equals("secure")){ //
         		return secureRandomUnifromObject.nextGaussian(); //Return values from default algorithm for normal distribution, using SecureRandom
      		}//End if
      		return randomUniformObject.nextGaussian(); //Return values from default algorithm for normal distribution, using Random
   	}//End nextGaussian
   	//Getters
   	public double getRandomUniformNum(){
      		return randomUniformNum;
   	}//End getRandomUniformNum
   	public String getRandomChoice(){
      		return randomChoice;
   	}//End getRandomChoice
   	//Setters
   	public void setRandomUniformNum(double randomUniformNumInput){
      		randomUniformNum = randomUniformNumInput;
   	}//End setRandomUniformNum
   	public void setRandomChoice(String randomChoiceInput){
      		randomChoice = randomChoiceInput;
   	}//End setRandomChoice
}//End ProbabilityDistribution
